# 01 - Introduction & VertiPaq Engine

## เนื้อหาหลักสูตร

โมดูลนี้แนะนำแนวคิดพื้นฐานเกี่ยวกับ Power BI Semantic Model และปูพื้นฐานความเข้าใจเกี่ยวกับ VertiPaq Engine ซึ่งเป็น Storage Engine ที่ Power BI ใช้ในการจัดเก็บและประมวลผลข้อมูลใน Semantic Model

> **Data Source หลักของหลักสูตร:** หลักสูตรนี้ใช้ **AdventureWorksDW** เป็น Data Source หลักสำหรับตัวอย่างและแบบฝึกหัดทั้งหมด

---

## 📋 หัวข้อการเรียนรู้

### Part 1: Power BI Semantic Model Introduction

#### 1. บทนำเกี่ยวกับ Power BI Semantic Model

- ความแตกต่างระหว่าง Data Model และ Semantic Model
- ความสำคัญของ Semantic Model ที่ดี
- Semantic Model Architecture

#### 2. Power BI Process ⭐

การประมวลผล DAX (และ MDX) ใน Power BI ใช้ 2 องค์ประกอบหลักที่ทำงานร่วมกัน:

##### Formula Engine (FE)
- **หน้าที่**: วิเคราะห์และประมวลผลคำสั่ง DAX หรือ MDX
- **การทำงาน**:
  - แปลความหมายของคำสั่ง
  - ตรวจสอบไวยากรณ์
  - วางแผนการดำเนินการ
  - ส่งคำขอข้อมูลไปยัง Storage Engine
- **ผลลัพธ์**: ส่งคืนผลลัพธ์สุดท้ายให้ผู้ใช้

##### Storage Engine (SE)
- **หน้าที่**: จัดการการดึงข้อมูลจากแหล่งที่เก็บข้อมูล
- **การทำงาน**:
  - รับคำขอจาก Formula Engine
  - ดึงข้อมูลจากหน่วยความจำหรือดิสก์
  - ใช้เทคนิคการจัดเก็บแบบคอลัมน์และการบีบอัดข้อมูล
- **ผลลัพธ์**: ส่งข้อมูลที่ดึงมาให้ Formula Engine

#### 3. Relationships เป็นหัวใจของ Semantic Model ⭐

- Relationships ช่วยเชื่อมโยงข้อมูลระหว่างตาราง
- ไม่จำเป็นต้องรวมข้อมูลทั้งหมดไว้ในตารางเดียว
- ลดความซับซ้อนและเพิ่มประสิทธิภาพ
- **👉 เรียนรู้เพิ่มเติมในโมดูล 04-Relationships**

---

### Part 2: VertiPaq Engine ⭐ **ปูพื้นฐานสำคัญ**

#### 1. VertiPaq Engine คืออะไร

VertiPaq เป็น **In-Memory Storage Engine** ที่ใช้ใน:
- Power BI
- SQL Server Analysis Services (SSAS) Tabular
- Power Pivot ใน Excel

**คุณสมบัติหลัก:**
- ออกแบบมาเพื่อรองรับการประมวลผลข้อมูลขนาดใหญ่ได้อย่างรวดเร็ว
- ใช้ **Columnar Storage** และ **Data Compression** ขั้นสูง
- ทำงานในหน่วยความจำ (In-Memory) ทำให้เร็วมาก

#### 2. ทำไม VertiPaq ถึงเร็วกว่าระบบทั่วไป

##### 2.1 Columnar Storage (โครงสร้างการจัดเก็บแบบคอลัมน์)

**ความแตกต่างจาก Row-Based Database:**
- **Row-Based**: เก็บข้อมูลเป็นแถว ๆ
- **VertiPaq**: เก็บข้อมูลเป็นคอลัมน์

**ข้อดี:**
- เรียกใช้เฉพาะคอลัมน์ที่จำเป็นต่อการคำนวณ
- ลดจำนวนข้อมูลที่ต้องอ่าน
- ลดเวลาในการดึงข้อมูล
- มีประสิทธิภาพสูงสำหรับ Data Analytics

##### 2.2 Data Compression (เทคนิคบีบอัดข้อมูล)

VertiPaq ใช้เทคนิคการบีบอัดข้อมูลหลายรูปแบบ:

**1. Value Encoding (Bit Packing)**
- ใช้บิตแทนค่าจริงที่มีช่วงค่าจำกัด
- ลดขนาดของข้อมูลโดยไม่เสียความแม่นยำ

**2. Dictionary Encoding (เข้ารหัสแบบพจนานุกรม)**
- สร้าง Dictionary ของค่าที่ไม่ซ้ำกันในแต่ละคอลัมน์
- เก็บเพียง Reference ID ไปยังค่าใน Dictionary
- แทนที่จะเก็บค่าซ้ำ ๆ
- ลดพื้นที่จัดเก็บและเพิ่มความเร็ว

**3. Run-Length Encoding (RLE) (เข้ารหัสแบบจำนวนซ้ำ)**
- เมื่อค่าต่อเนื่องกันมีค่าซ้ำกัน RLE จะบันทึกค่าพร้อมจำนวนครั้งที่ซ้ำ
- แทนที่จะบันทึกค่าเดิมซ้ำ ๆ
- **มีประสิทธิภาพสูงเมื่อใช้กับคอลัมน์ที่ถูกจัดเรียง (Sorted Columns)**

#### 3. การจัดเรียงข้อมูลส่งผลต่อ VertiPaq อย่างไร

**การเรียงลำดับคอลัมน์ (Sorting Columns)** มีผลต่อประสิทธิภาพของการบีบอัดข้อมูลด้วยวิธี RLE:

- หากคอลัมน์มีค่าซ้ำเรียงติดกันมากขึ้น → การทำงานของ Run-Length Encoding จะมีประสิทธิภาพมากขึ้น
- ส่งผลให้การบีบอัดข้อมูลมีประสิทธิภาพมากขึ้น

**Best Practice:**
- พิจารณาให้คอลัมน์ที่มีการเปลี่ยนแปลงน้อยอยู่ในลำดับหน้า
- เพื่อให้ VertiPaq สามารถใช้ RLE ได้อย่างเต็มที่

#### 4. Low Cardinality และผลกระทบต่อ Performance

**Low Cardinality** = คอลัมน์ที่มีค่าซ้ำกันมาก (Cardinality ต่ำ)

**เหตุผลที่ VertiPaq ชอบ Low Cardinality:**
- Dictionary Encoding ทำงานได้ดีกับค่าซ้ำกันมาก
- RLE Encoding ทำงานได้ดีกับค่าซ้ำกันเรียงติดกัน
- ลดขนาดข้อมูล → ลดการใช้หน่วยความจำ → เพิ่มความเร็ว

**Cardinality คืออะไร?**
- **Cardinality = จำนวนค่าที่ไม่ซ้ำกัน (unique values) ในคอลัมน์**

**ตัวอย่างง่ายๆ:**
```
ตารางนักเรียน (มี 4 แถว)
┌──────────┬─────────┬──────────┐
│ ชื่อ      │ เพศ     │ เกรด     │
├──────────┼─────────┼──────────┤
│ สมชาย    │ ชาย     │ A        │
│ สมหญิง   │ หญิง    │ B        │
│ วิชัย     │ ชาย     │ A        │
│ วิไล      │ หญิง    │ C        │
└──────────┴─────────┴──────────┘

- คอลัมน์ "เพศ": มีค่าซ้ำกันมาก (ชาย, หญิง, ชาย, หญิง) 
  → Cardinality = 2 (ต่ำ ✅ Low Cardinality)
  → แต่ละค่าใช้ซ้ำ 2 ครั้ง

- คอลัมน์ "เกรด": มีค่าซ้ำกัน (A, B, A, C)
  → Cardinality = 3 (ต่ำ ✅ Low Cardinality)
  → A ซ้ำ 2 ครั้ง

- คอลัมน์ "ชื่อ": ไม่มีค่าซ้ำกันเลย (สมชาย, สมหญิง, วิชัย, วิไล)
  → Cardinality = 4 (สูง ❌ High Cardinality)
  → แต่ละชื่อไม่ซ้ำกันเลย
```

**ทำไม VertiPaq ชอบ Low Cardinality?**
- **Low Cardinality** = คอลัมน์ที่มีค่าซ้ำกันมาก = Cardinality ต่ำ (น้อยกว่าจำนวนแถว)
  - เก็บข้อมูลได้ง่าย = ประหยัดพื้นที่ = เร็วขึ้น ✅
  
- **High Cardinality** = คอลัมน์ที่มีค่าซ้ำกันน้อยหรือไม่มีเลย = Cardinality สูง (ใกล้เคียงหรือเท่ากับจำนวนแถว)
  - เก็บข้อมูลยาก = ใช้พื้นที่มาก = ช้าลง ❌

**ตัวอย่าง Cardinality สูง (ไม่ดี):**
```
ตารางการขาย (มี 3 แถว)
┌──────────────┬──────────────────────┐
│ รหัสใบเสร็จ   │ เวลาที่ซื้อ (Timestamp)│
├──────────────┼──────────────────────┤
│ INV-001      │ 2024-01-15 10:23:45.123│
│ INV-002      │ 2024-01-15 10:23:45.456│
│ INV-003      │ 2024-01-15 10:23:45.789│
└──────────────┴──────────────────────┘

- Timestamp แบบ Milliseconds: ไม่มีค่าซ้ำกันเลย
  → Cardinality = 3 (สูงมาก ❌ High Cardinality)
  → เท่ากับจำนวนแถวทั้งหมด (แต่ละแถวมีค่าไม่ซ้ำกัน)
```

**วิธีลด Cardinality (ทำให้มีประสิทธิภาพมากขึ้น):**

##### วิธีที่ 1: แบ่งคอลัมน์ที่มี Cardinality สูงออกเป็นหลายคอลัมน์

**ตัวอย่าง: แบ่ง DateTime ออกเป็น Date และ Time**

❌ **ไม่ดี (Cardinality สูง - ไม่มีค่าซ้ำกัน):**
```
ตารางการขาย (มี 3 แถว)
┌──────────────┬──────────────────────┐
│ รหัสใบเสร็จ   │ เวลาที่ซื้อ (DateTime) │
├──────────────┼──────────────────────┤
│ INV-001      │ 2024-01-15 10:23:45.123│
│ INV-002      │ 2024-01-15 10:23:45.456│
│ INV-003      │ 2024-01-15 10:23:45.789│
└──────────────┴──────────────────────┘
→ ไม่มีค่าซ้ำกันเลย = Cardinality = 3 (สูงมาก ❌)
→ เท่ากับจำนวนแถวทั้งหมด
```

✅ **ดี (Cardinality ต่ำ - มีค่าซ้ำกันมาก):**
```
ตารางการขาย (มี 3 แถว)
┌──────────────┬────────────┬──────────┐
│ รหัสใบเสร็จ   │ วันที่ซื้อ  │ ช่วงเวลา  │
├──────────────┼────────────┼──────────┤
│ INV-001      │ 2024-01-15 │ เช้า      │
│ INV-002      │ 2024-01-15 │ เช้า      │
│ INV-003      │ 2024-01-15 │ เช้า      │
└──────────────┴────────────┴──────────┘
→ วันที่ซื้อ: มีค่าซ้ำกัน 3 ครั้ง = Cardinality = 1 (ต่ำมาก ✅)
→ ช่วงเวลา: มีค่าซ้ำกัน 3 ครั้ง = Cardinality = 1 (ต่ำมาก ✅)
```

##### วิธีที่ 2: ใช้ Dimension Tables แทนการเก็บข้อมูลใน Fact Table โดยตรง

**ตัวอย่าง: เก็บข้อมูลสินค้า**

❌ **ไม่ดี (เก็บข้อมูลสินค้าในตารางการขาย - มีค่าซ้ำกันน้อย):**
```
ตารางการขาย (Fact Table - มี 3 แถว)
┌──────────┬──────────────┬──────────┬──────────┐
│ รหัสใบเสร็จ│ รหัสสินค้า   │ ชื่อสินค้า│ ราคา     │
├──────────┼──────────────┼──────────┼──────────┤
│ INV-001  │ P001        │ น้ำดื่ม   │ 20       │
│ INV-002  │ P002        │ ขนม      │ 15       │
│ INV-003  │ P001        │ น้ำดื่ม   │ 20       │
└──────────┴──────────────┴──────────┴──────────┘
→ ชื่อสินค้า: "น้ำดื่ม" ซ้ำ 2 ครั้ง, "ขนม" 1 ครั้ง
  = Cardinality = 2 (สูง ❌ - มีค่าซ้ำกันน้อย)
→ ราคา: 20 ซ้ำ 2 ครั้ง, 15 ซ้ำ 1 ครั้ง
  = Cardinality = 2 (สูง ❌ - มีค่าซ้ำกันน้อย)
```

✅ **ดี (แยกเป็น Dimension Table - มีค่าซ้ำกันมาก):**
```
ตารางการขาย (Fact Table - มี 3 แถว)
┌──────────┬──────────────┐
│ รหัสใบเสร็จ│ รหัสสินค้า   │
├──────────┼──────────────┤
│ INV-001  │ P001        │
│ INV-002  │ P002        │
│ INV-003  │ P001        │
└──────────┴──────────────┘
→ รหัสสินค้า: P001 ซ้ำ 2 ครั้ง, P002 ซ้ำ 1 ครั้ง
  = Cardinality = 2 (ต่ำ ✅ - มีค่าซ้ำกันมาก)

ตารางสินค้า (Dimension Table - มี 2 แถว)
┌──────────────┬──────────┬──────────┐
│ รหัสสินค้า    │ ชื่อสินค้า│ ราคา     │
├──────────────┼──────────┼──────────┤
│ P001        │ น้ำดื่ม   │ 20       │
│ P002        │ ขนม      │ 15       │
└──────────────┴──────────┴──────────┘
→ เก็บข้อมูลสินค้าแยกต่างหาก (Cardinality ต่ำ ✅)
→ เมื่อมีข้อมูลการขายมากขึ้น รหัสสินค้าใน Fact Table จะซ้ำกันมากขึ้น
```

##### วิธีที่ 3: ใช้ Calculated Columns สำหรับค่าที่คำนวณได้

**ตัวอย่าง: แทนที่จะเก็บ "ช่วงอายุ" เก็บ "ปีเกิด" แล้วคำนวณ**

❌ **ไม่ดี (เก็บช่วงอายุโดยตรง - มีค่าซ้ำกันน้อย):**
```
ตารางลูกค้า (มี 3 แถว)
┌──────────┬──────────┬──────────┐
│ รหัสลูกค้า │ ชื่อ     │ ช่วงอายุ │
├──────────┼──────────┼──────────┤
│ C001    │ สมชาย    │ 20-30    │
│ C002    │ สมหญิง   │ 20-30    │
│ C003    │ วิชัย     │ 30-40    │
└──────────┴──────────┴──────────┘
→ ช่วงอายุ: "20-30" ซ้ำ 2 ครั้ง, "30-40" ซ้ำ 1 ครั้ง
  = Cardinality = 2 (สูง ❌ - มีค่าซ้ำกันน้อย)
```

✅ **ดี (เก็บปีเกิด แล้วคำนวณช่วงอายุ - มีค่าซ้ำกันมากขึ้น):**
```
ตารางลูกค้า (มี 3 แถว)
┌──────────┬──────────┬──────────┐
│ รหัสลูกค้า │ ชื่อ     │ ปีเกิด   │
├──────────┼──────────┼──────────┤
│ C001    │ สมชาย    │ 1995     │
│ C002    │ สมหญิง   │ 1996     │
│ C003    │ วิชัย     │ 1985     │
└──────────┴──────────┴──────────┘
→ ปีเกิด: ไม่มีค่าซ้ำกัน = Cardinality = 3
  แต่เมื่อมีลูกค้ามากขึ้น ปีเกิดจะซ้ำกันมากขึ้น
  (เช่น มีลูกค้าเกิดปี 1995 หลายคน)
  → Cardinality จะลดลง (ต่ำกว่า ✅)

แล้วสร้าง Calculated Column:
ช่วงอายุ = IF(YEAR(TODAY()) - [ปีเกิด] <= 30, "20-30", "30-40")
→ คำนวณได้ ไม่ต้องเก็บ (ประหยัดพื้นที่ ✅)
```

**สรุป:**
- ✅ **Low Cardinality = ดี** 
  - = คอลัมน์ที่มีค่าซ้ำกันมาก = Cardinality ต่ำ
  - → เร็ว, ประหยัดพื้นที่
  
- ❌ **High Cardinality = ไม่ดี**
  - = คอลัมน์ที่มีค่าซ้ำกันน้อยหรือไม่มีเลย = Cardinality สูง
  - → ช้า, ใช้พื้นที่มาก
  
- 🎯 **วิธีลด Cardinality**: แบ่งคอลัมน์, ใช้ Dimension Tables, ใช้ Calculated Columns

#### 5. Sorted Data และ Encoding

- **RLE (Run-Length Encoding) ทำงานได้ดีกับข้อมูลที่เรียงลำดับ**
- เมื่อข้อมูลเรียงลำดับ RLE สามารถบีบอัดข้อมูลได้ดีมาก
- ตัวอย่าง: ข้อมูล Sales ที่เรียงตาม Date, Product จะทำให้ RLE Encoding มีประสิทธิภาพสูง
- การจัดเรียงข้อมูลควรทำที่ Fact Table โดยใช้คอลัมน์ที่มีความสำคัญสูงสุด
- Partitioning สามารถช่วยให้แต่ละ Partition มีข้อมูลเรียงลำดับได้

#### 6. Best Practices ในการใช้ VertiPaq ให้มีประสิทธิภาพสูงสุด

##### 6.1 ควบคุมจำนวนคอลัมน์
- คอลัมน์ที่ไม่จำเป็น → ลบทิ้ง เพื่อลดขนาดของโมเดล

##### 6.2 ลดจำนวนค่าที่แตกต่างกันมากเกินไปในคอลัมน์ (Cardinality Reduction)
- ค่าที่แตกต่างกันมากเกินไป → ทำให้ Dictionary Encoding ทำงานได้ไม่ดี
- **ตัวอย่าง**: วันที่แบบเต็มรูปแบบ (2025-02-16 14:23:45) อาจลดลงเป็น แค่วันที่ (2025-02-16)

##### 6.3 จัดเรียงลำดับข้อมูลให้เหมาะสม
- นำคอลัมน์ที่มีค่าซ้ำกันมากไว้ลำดับต้น ๆ
- เพื่อให้ RLE บีบอัดข้อมูลได้ดีที่สุด

##### 6.4 ใช้ Measures มากกว่า Calculated Columns
- **Measures (DAX)**: คำนวณแบบ Dynamic โดยใช้หน่วยความจำได้มีประสิทธิภาพกว่า
- **Calculated Columns**: คำนวณและเก็บค่าลงในโมเดล → ทำให้ขนาดไฟล์ใหญ่ขึ้น

##### 6.5 Best Practices สรุป
1. **ลด Cardinality**:
   - หลีกเลี่ยงคอลัมน์ที่มีค่าซ้ำกันน้อยหรือไม่มีเลย (High Cardinality)
   - ใช้ Dimension Tables แทนการเก็บข้อมูลโดยตรงใน Fact Table
   - แบ่งคอลัมน์ที่มี Cardinality สูงออกเป็นหลายคอลัมน์
   - เลือกคอลัมน์ที่มีค่าซ้ำกันมาก (Low Cardinality) แทน

2. **เรียงข้อมูล (Sorting)**:
   - เรียงข้อมูลใน Fact Table ตามคอลัมน์ที่ใช้บ่อยที่สุด
   - ใช้ Date, Product Key, Customer Key ในการเรียงลำดับ
   - เรียงข้อมูลก่อน Import ขึ้น Semantic Model

3. **เลือก Data Types ที่เหมาะสม**:
   - ใช้ Integer แทน Text เมื่อเป็นไปได้
   - ใช้ Date แทน DateTime ถ้าไม่จำเป็นต้องใช้เวลา
   - หลีกเลี่ยงการใช้ Large Text Fields

#### 7. สรุปจุดเด่นของ VertiPaq Engine

1. **Columnar Storage** → อ่านเฉพาะข้อมูลที่จำเป็น ทำให้ดึงข้อมูลเร็ว
2. **Data Compression** → บีบอัดข้อมูล ลดการใช้หน่วยความจำ
3. **การเรียงลำดับข้อมูล** ช่วยเพิ่มประสิทธิภาพการบีบอัด
4. **เหมาะสำหรับงานด้าน Data Analytics และ OLAP**
5. **ทำงานบน In-Memory** ช่วยให้คำนวณและวิเคราะห์ข้อมูลได้รวดเร็ว

---

### Part 3: External Tools สำหรับจัดการ Semantic Model ⭐

#### 1. Power BI Desktop Views

##### Model View
- จัดการ Semantic Model
- ดูและแก้ไข Relationships
- ตั้งค่า Properties ของ Tables และ Columns

##### DAX Query View
- เขียนและทดสอบ DAX Queries
- วิเคราะห์ผลลัพธ์ของ Query
- Debugging DAX Code

##### TMDL View
- จัดการ Model ผ่าน Tabular Model Definition Language
- แก้ไข Metadata ผ่าน Text Editor
- เหมาะสำหรับ Advanced Users

#### 2. DAX Studio ⭐ **แนะนำตั้งแต่ต้น**

**DAX Studio** เป็นเครื่องมือสำคัญสำหรับ:
- วิเคราะห์และปรับปรุงประสิทธิภาพ DAX Queries
- ใช้ VertiPaq Analyzer เพื่อวิเคราะห์ Cardinality และ Compression
- Query Profiling เพื่อดู Query Execution Plan
- ดู Storage Engine และ Formula Engine Information

**วิธีใช้งาน DAX Studio:**
1. เปิด Power BI Desktop
2. ไปที่ **External Tools** > **DAX Studio**
3. หรือเปิด DAX Studio แยก แล้วเชื่อมต่อกับ Power BI Desktop

**VertiPaq Analyzer ใน DAX Studio:**
- วิเคราะห์ Cardinality ของแต่ละคอลัมน์
- ดูขนาดข้อมูลและ Compression Ratio
- ช่วยระบุคอลัมน์ที่มี High Cardinality
- แนะนำแนวทางปรับปรุงประสิทธิภาพ

**👉 แนะนำให้ใช้ VertiPaq Analyzer ตั้งแต่ต้น** เพื่อให้เห็นภาพชัดเจนว่า VertiPaq ทำงานอย่างไรกับข้อมูลจริง

#### 3. Tabular Editor ⭐ **แนะนำตั้งแต่ต้น**

**Tabular Editor** เป็นเครื่องมือที่ช่วยให้การจัดการ Semantic Model เร็วขึ้นมาก:

**ข้อดี:**
- จัดการ Metadata ได้เร็วกว่า Power BI Desktop
- ตั้งค่า Properties ที่ซับซ้อนได้ง่าย
- สร้างและแก้ไข Measures/Columns จำนวนมากได้เร็ว
- จัดการ Calculation Groups ได้สะดวก
- Export/Import Metadata
- รองรับ Scripting (C#) สำหรับ Automation

**ประเภท:**
- **Tabular Editor 2 (Open Source)**: ฟรี, มีข้อจำกัดบางอย่าง
- **Tabular Editor 3 (Commercial)**: ใช้ง่ายกว่า, เสียค่าใช้จ่ายรายเดือน

**วิธีใช้งาน Tabular Editor:**
1. ใน Power BI Desktop ไปที่ **External Tools** > **Tabular Editor**
2. หรือเปิด Tabular Editor แยก แล้วเชื่อมต่อกับ Power BI Desktop
3. จะเห็นโครงสร้าง Semantic Model ทั้งหมดใน TOM Explorer

**👉 แนะนำให้ใช้ Tabular Editor ตั้งแต่ต้น** เพื่อให้เห็นว่าสามารถทำงานกับ Model ได้เร็วขึ้นอย่างไร

**ตัวอย่างการใช้ Tabular Editor:**
- ตั้งค่า Properties หลายคอลัมน์พร้อมกัน
- สร้าง Measures จำนวนมากได้เร็ว
- จัดการ Calculation Groups
- Export/Import Metadata สำหรับ Version Control

#### 4. เครื่องมืออื่นๆ

##### ALM Toolkit
- Version Control สำหรับ Semantic Model
- Compare Models เพื่อดูความแตกต่าง
- Deploy Models จาก Development ไป Production

##### Best Practice Analyzer (BPA)
- ตรวจสอบ Best Practices ใน Semantic Model
- แนะนำแนวทางปรับปรุง
- รองรับทั้ง Tabular Editor และ DAX Studio

---

### Part 4: ภาพรวมของหลักสูตร

หลักสูตรนี้แบ่งออกเป็น 13 โมดูลหลัก:

1. **Introduction & VertiPaq Engine** (โมดูลนี้) - ปูพื้นฐานสำคัญ
2. **Data Sources** - การเชื่อมต่อและเตรียมข้อมูล
3. **Data Modeling Basics** - Star Schema, Fact/Dimension Tables
4. **Relationships** ⭐ - หัวใจของหลักสูตร
5. **Dimension Table Design** - Surrogate Keys, Hierarchies, SCD
6. **Date Dimensions & Relationships** - Conformed Date Dimension
7. **Fact Tables Design** - Explicit Measures, Calculation Groups
8. **Performance Optimization** - VertiPaq Optimization
9. **Best Practices** - แนวทางปฏิบัติที่ดี
10. **Advanced Modeling** - Bidirectional Filters, Many-to-Many
11. **Case Studies** - โครงการตัวอย่างจริง
12. **Security (RLS)** - Row-Level Security
13. **Incremental Refresh & Partitioning** - การจัดการ Large Models

---

## 🎯 วัตถุประสงค์

หลังจากจบโมดูลนี้ ผู้เรียนจะสามารถ:
- เข้าใจ Power BI Process และการทำงานของ Formula Engine และ Storage Engine
- เข้าใจ VertiPaq Engine อย่างลึกซึ้ง
- เข้าใจความสำคัญของ Low Cardinality และ Sorted Data ต่อ Performance
- วิเคราะห์ Cardinality ด้วย VertiPaq Analyzer
- ใช้ Tabular Editor จัดการ Semantic Model ได้อย่างมีประสิทธิภาพ
- เข้าใจความสำคัญของ Semantic Model และ Relationships
- เข้าใจภาพรวมของหลักสูตร

---

## 🔗 การเชื่อมโยงกับโมดูลอื่น

- **02-Data-Sources**: เข้าใจ VertiPaq จะช่วยในการเตรียมข้อมูลเพื่อลด Cardinality
- **03-Data-Modeling-Basics**: เข้าใจ VertiPaq จะช่วยในการออกแบบ Schema
- **04-Relationships**: Low Cardinality จำเป็นสำหรับการสร้าง Relationships ที่มีประสิทธิภาพ (Relationships เป็นหัวใจของหลักสูตร)
- **08-Performance-Optimization**: ความเข้าใจ VertiPaq เป็นพื้นฐานสำคัญ
